/**
 * @file account_manager.cpp
 * @brief 账户注册管理实现
 */

#include "account_manager.h"
#include "../config/server_config.h"
#include "../../trading/account_registry.h"
#include "../../core/logger.h"
#include <sstream>
#include <algorithm>

namespace trading {
namespace server {

<<<<<<< HEAD
okx::OKXRestAPI* get_api_for_strategy(const std::string& strategy_id) {
    okx::OKXRestAPI* api = g_account_registry.get_okx_api(strategy_id);
    if (!api) {
        std::cout << "[账户] 策略 " << strategy_id << " 未注册账户，且无默认账户\n";
    }
    return api;
}

okx::OKXRestAPI* get_okx_api_for_strategy(const std::string& strategy_id) {
    return get_api_for_strategy(strategy_id);
}

binance::BinanceRestAPI* get_binance_api_for_strategy(const std::string& strategy_id) {
    binance::BinanceRestAPI* api = g_account_registry.get_binance_api(strategy_id);
    if (!api) {
        std::cout << "[账户] 策略 " << strategy_id << " 未注册 Binance 账户，且无默认账户\n";
    }
    return api;
}

bool register_strategy_account(const std::string& strategy_id,
                               const std::string& api_key,
                               const std::string& secret_key,
                               const std::string& passphrase,
                               bool is_testnet) {
    bool success = g_account_registry.register_okx_account(
        strategy_id, api_key, secret_key, passphrase, is_testnet
    );

    if (success) {
        std::cout << "[账户] ✓ 策略 " << strategy_id << " 注册成功"
                  << " | 模式: " << (is_testnet ? "模拟盘" : "实盘")
                  << " | API Key: " << api_key.substr(0, 8) << "...\n";
    }

    return success;
}

bool unregister_strategy_account(const std::string& strategy_id) {
    bool success = g_account_registry.unregister_account(strategy_id, ExchangeType::OKX);

    if (success) {
        std::cout << "[账户] ✓ 策略 " << strategy_id << " 已注销\n";
    } else {
        std::cout << "[账户] 策略 " << strategy_id << " 未找到\n";
    }

    return success;
}

=======
// ==================== 通用辅助函数 ====================

bool validate_strategy_id(const std::string& strategy_id) {
    if (strategy_id.empty()) {
        return false;
    }

    // 检查是否包含非法字符
    for (char c : strategy_id) {
        if (!std::isalnum(c) && c != '_' && c != '-') {
            return false;
        }
    }

    return true;
}

std::string mask_api_key(const std::string& api_key) {
    if (api_key.length() <= 8) {
        return "****";
    }

    std::string masked = api_key.substr(0, 4);
    masked += "****";
    masked += api_key.substr(api_key.length() - 4);

    return masked;
}

// ==================== OKX 专用辅助函数 ====================

AccountResult validate_credentials(const std::string& api_key,
                                   const std::string& secret_key,
                                   const std::string& passphrase) {
    if (api_key.empty() || api_key.length() < constants::MIN_API_KEY_LENGTH) {
        return AccountResult(
            AccountErrorCode::INVALID_API_KEY,
            "API Key 无效或长度不足"
        );
    }

    if (secret_key.empty() || secret_key.length() < constants::MIN_SECRET_KEY_LENGTH) {
        return AccountResult(
            AccountErrorCode::INVALID_SECRET_KEY,
            "Secret Key 无效或长度不足"
        );
    }

    if (passphrase.empty() || passphrase.length() < constants::MIN_PASSPHRASE_LENGTH) {
        return AccountResult(
            AccountErrorCode::INVALID_PASSPHRASE,
            "Passphrase 无效或为空"
        );
    }

    return AccountResult(AccountErrorCode::SUCCESS, "凭证验证通过");
}

// ==================== Binance 专用辅助函数 ====================

AccountResult validate_credentials_no_passphrase(const std::string& api_key,
                                                 const std::string& secret_key) {
    if (api_key.empty() || api_key.length() < constants::MIN_API_KEY_LENGTH) {
        return AccountResult(
            AccountErrorCode::INVALID_API_KEY,
            "API Key 无效或长度不足"
        );
    }

    if (secret_key.empty() || secret_key.length() < constants::MIN_SECRET_KEY_LENGTH) {
        return AccountResult(
            AccountErrorCode::INVALID_SECRET_KEY,
            "Secret Key 无效或长度不足"
        );
    }

    return AccountResult(AccountErrorCode::SUCCESS, "凭证验证通过");
}

binance::MarketType parse_market_type(const std::string& market) {
    std::string market_lower = market;
    std::transform(market_lower.begin(), market_lower.end(), market_lower.begin(), ::tolower);

    if (market_lower == "spot") {
        return binance::MarketType::SPOT;
    } else if (market_lower == "coin_futures" || market_lower == "coin-futures") {
        return binance::MarketType::COIN_FUTURES;
    }

    return binance::MarketType::FUTURES;  // 默认
}

// ==================== OKX 账户管理接口实现 ====================

// ==================== OKX 账户管理接口实现 ====================

okx::OKXRestAPI* get_okx_api_for_strategy(const std::string& strategy_id) {
    // 参数验证
    if (!validate_strategy_id(strategy_id)) {
        LOG_WARN("[账户管理|OKX] 无效的策略ID: " + strategy_id);
        return nullptr;
    }

    okx::OKXRestAPI* api = g_account_registry.get_okx_api(strategy_id);

    if (!api) {
        LOG_WARN("[账户管理|OKX] 策略 " + strategy_id + " 未注册账户，且无默认账户");
    }

    return api;
}

AccountResult register_okx_account(const std::string& strategy_id,
                                   const std::string& api_key,
                                   const std::string& secret_key,
                                   const std::string& passphrase,
                                   bool is_testnet) {
    // 1. 验证策略ID
    if (!validate_strategy_id(strategy_id)) {
        LOG_ERROR("[账户管理|OKX] 注册失败 - 无效的策略ID: " + strategy_id);
        return AccountResult(
            AccountErrorCode::INVALID_STRATEGY_ID,
            "策略ID无效或包含非法字符"
        );
    }

    // 2. 验证凭证
    AccountResult validation = validate_credentials(api_key, secret_key, passphrase);
    if (!validation.is_success()) {
        LOG_ERROR("[账户管理|OKX] 注册失败 - " + validation.message);
        return validation;
    }

    // 3. 检查是否已存在
    if (g_account_registry.is_registered(strategy_id, ExchangeType::OKX)) {
        LOG_WARN("[账户管理|OKX] 策略 " + strategy_id + " 已注册，请使用更新接口");
        return AccountResult(
            AccountErrorCode::ACCOUNT_ALREADY_EXISTS,
            "账户已存在，请使用更新接口"
        );
    }

    // 4. 执行注册
    bool success = false;
    try {
        success = g_account_registry.register_okx_account(
            strategy_id, api_key, secret_key, passphrase, is_testnet
        );
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理|OKX] 注册异常: " + std::string(e.what()));
        return AccountResult(
            AccountErrorCode::INTERNAL_ERROR,
            "注册过程发生异常: " + std::string(e.what())
        );
    }

    if (success) {
        // 使用审计日志记录敏感操作
        std::stringstream audit_msg;
        audit_msg << "策略: " << strategy_id
                  << " | 交易所: OKX"
                  << " | 模式: " << (is_testnet ? constants::MODE_TESTNET : constants::MODE_LIVE)
                  << " | API Key: " << mask_api_key(api_key);
        LOG_AUDIT("账户注册", audit_msg.str());

        LOG_INFO("[账户管理|OKX] ✓ 策略 " + strategy_id + " 注册成功");
        return AccountResult(AccountErrorCode::SUCCESS, "注册成功");
    } else {
        LOG_ERROR("[账户管理|OKX] 策略 " + strategy_id + " 注册失败");
        return AccountResult(
            AccountErrorCode::REGISTRATION_FAILED,
            "注册失败，请检查参数或联系管理员"
        );
    }
}

AccountResult update_okx_account(const std::string& strategy_id,
                                 const std::string& api_key,
                                 const std::string& secret_key,
                                 const std::string& passphrase,
                                 bool is_testnet) {
    // 1. 验证策略ID
    if (!validate_strategy_id(strategy_id)) {
        LOG_ERROR("[账户管理|OKX] 更新失败 - 无效的策略ID: " + strategy_id);
        return AccountResult(
            AccountErrorCode::INVALID_STRATEGY_ID,
            "策略ID无效"
        );
    }

    // 2. 验证凭证
    AccountResult validation = validate_credentials(api_key, secret_key, passphrase);
    if (!validation.is_success()) {
        LOG_ERROR("[账户管理|OKX] 更新失败 - " + validation.message);
        return validation;
    }

    // 3. 执行更新
    bool success = false;
    try {
        success = g_account_registry.update_okx_account(
            strategy_id, api_key, secret_key, passphrase, is_testnet
        );
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理|OKX] 更新异常: " + std::string(e.what()));
        return AccountResult(
            AccountErrorCode::INTERNAL_ERROR,
            "更新过程发生异常: " + std::string(e.what())
        );
    }

    if (success) {
        std::stringstream audit_msg;
        audit_msg << "策略: " << strategy_id
                  << " | 交易所: OKX"
                  << " | 模式: " << (is_testnet ? constants::MODE_TESTNET : constants::MODE_LIVE)
                  << " | API Key: " << mask_api_key(api_key);
        LOG_AUDIT("账户更新", audit_msg.str());

        LOG_INFO("[账户管理|OKX] ✓ 策略 " + strategy_id + " 更新成功");
        return AccountResult(AccountErrorCode::SUCCESS, "更新成功");
    } else {
        LOG_ERROR("[账户管理|OKX] 策略 " + strategy_id + " 更新失败");
        return AccountResult(
            AccountErrorCode::UPDATE_FAILED,
            "更新失败"
        );
    }
}

AccountResult unregister_okx_account(const std::string& strategy_id) {
    // 1. 验证策略ID
    if (!validate_strategy_id(strategy_id)) {
        LOG_ERROR("[账户管理|OKX] 注销失败 - 无效的策略ID: " + strategy_id);
        return AccountResult(
            AccountErrorCode::INVALID_STRATEGY_ID,
            "策略ID无效"
        );
    }

    // 2. 检查是否存在
    if (!g_account_registry.is_registered(strategy_id, ExchangeType::OKX)) {
        LOG_WARN("[账户管理|OKX] 策略 " + strategy_id + " 未找到");
        return AccountResult(
            AccountErrorCode::ACCOUNT_NOT_FOUND,
            "账户未找到"
        );
    }

    // 3. 执行注销
    bool success = false;
    try {
        success = g_account_registry.unregister_account(strategy_id, ExchangeType::OKX);
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理|OKX] 注销异常: " + std::string(e.what()));
        return AccountResult(
            AccountErrorCode::INTERNAL_ERROR,
            "注销过程发生异常: " + std::string(e.what())
        );
    }

    if (success) {
        LOG_AUDIT("账户注销", "策略: " + strategy_id + " | 交易所: OKX");
        LOG_INFO("[账户管理|OKX] ✓ 策略 " + strategy_id + " 已注销");
        return AccountResult(AccountErrorCode::SUCCESS, "注销成功");
    } else {
        LOG_ERROR("[账户管理|OKX] 策略 " + strategy_id + " 注销失败");
        return AccountResult(
            AccountErrorCode::UNREGISTRATION_FAILED,
            "注销失败"
        );
    }
}

// ==================== Binance 账户管理接口实现 ====================

binance::BinanceRestAPI* get_binance_api_for_strategy(const std::string& strategy_id,
                                                       const std::string& market) {
    // 参数验证
    if (!validate_strategy_id(strategy_id)) {
        LOG_WARN("[账户管理|Binance] 无效的策略ID: " + strategy_id);
        return nullptr;
    }

    binance::BinanceRestAPI* api = nullptr;

    if (market.empty()) {
        // 使用默认市场
        api = g_account_registry.get_binance_api(strategy_id);
    } else {
        // 使用指定市场
        binance::MarketType market_type = parse_market_type(market);
        api = g_account_registry.get_binance_api(strategy_id, market_type);
    }

    if (!api) {
        LOG_WARN("[账户管理|Binance] 策略 " + strategy_id + " 未注册账户，且无默认账户");
    }

    return api;
}

AccountResult register_binance_account(const std::string& strategy_id,
                                       const std::string& api_key,
                                       const std::string& secret_key,
                                       bool is_testnet,
                                       const std::string& market) {
    // 1. 验证策略ID
    if (!validate_strategy_id(strategy_id)) {
        LOG_ERROR("[账户管理|Binance] 注册失败 - 无效的策略ID: " + strategy_id);
        return AccountResult(
            AccountErrorCode::INVALID_STRATEGY_ID,
            "策略ID无效或包含非法字符"
        );
    }

    // 2. 验证凭证（Binance不需要passphrase）
    AccountResult validation = validate_credentials_no_passphrase(api_key, secret_key);
    if (!validation.is_success()) {
        LOG_ERROR("[账户管理|Binance] 注册失败 - " + validation.message);
        return validation;
    }

    // 3. 解析市场类型
    binance::MarketType market_type = parse_market_type(market);

    // 4. 检查是否已存在
    if (g_account_registry.is_registered(strategy_id, ExchangeType::BINANCE)) {
        LOG_WARN("[账户管理|Binance] 策略 " + strategy_id + " 已注册，请使用更新接口");
        return AccountResult(
            AccountErrorCode::ACCOUNT_ALREADY_EXISTS,
            "账户已存在，请使用更新接口"
        );
    }

    // 5. 执行注册
    bool success = false;
    try {
        success = g_account_registry.register_binance_account(
            strategy_id, api_key, secret_key, is_testnet, market_type
        );
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理|Binance] 注册异常: " + std::string(e.what()));
        return AccountResult(
            AccountErrorCode::INTERNAL_ERROR,
            "注册过程发生异常: " + std::string(e.what())
        );
    }

    if (success) {
        std::stringstream audit_msg;
        audit_msg << "策略: " << strategy_id
                  << " | 交易所: Binance"
                  << " | 市场: " << market
                  << " | 模式: " << (is_testnet ? constants::MODE_TESTNET : constants::MODE_LIVE)
                  << " | API Key: " << mask_api_key(api_key);
        LOG_AUDIT("账户注册", audit_msg.str());

        LOG_INFO("[账户管理|Binance] ✓ 策略 " + strategy_id + " 注册成功");
        return AccountResult(AccountErrorCode::SUCCESS, "注册成功");
    } else {
        LOG_ERROR("[账户管理|Binance] 策略 " + strategy_id + " 注册失败");
        return AccountResult(
            AccountErrorCode::REGISTRATION_FAILED,
            "注册失败，请检查参数或联系管理员"
        );
    }
}

AccountResult update_binance_account(const std::string& strategy_id,
                                     const std::string& api_key,
                                     const std::string& secret_key,
                                     bool is_testnet,
                                     const std::string& market) {
    // 1. 验证策略ID
    if (!validate_strategy_id(strategy_id)) {
        LOG_ERROR("[账户管理|Binance] 更新失败 - 无效的策略ID: " + strategy_id);
        return AccountResult(
            AccountErrorCode::INVALID_STRATEGY_ID,
            "策略ID无效"
        );
    }

    // 2. 验证凭证
    AccountResult validation = validate_credentials_no_passphrase(api_key, secret_key);
    if (!validation.is_success()) {
        LOG_ERROR("[账户管理|Binance] 更新失败 - " + validation.message);
        return validation;
    }

    // 3. 解析市场类型
    binance::MarketType market_type = parse_market_type(market);

    // 4. 执行更新
    bool success = false;
    try {
        success = g_account_registry.update_binance_account(
            strategy_id, api_key, secret_key, is_testnet, market_type
        );
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理|Binance] 更新异常: " + std::string(e.what()));
        return AccountResult(
            AccountErrorCode::INTERNAL_ERROR,
            "更新过程发生异常: " + std::string(e.what())
        );
    }

    if (success) {
        std::stringstream audit_msg;
        audit_msg << "策略: " << strategy_id
                  << " | 交易所: Binance"
                  << " | 市场: " << market
                  << " | 模式: " << (is_testnet ? constants::MODE_TESTNET : constants::MODE_LIVE)
                  << " | API Key: " << mask_api_key(api_key);
        LOG_AUDIT("账户更新", audit_msg.str());

        LOG_INFO("[账户管理|Binance] ✓ 策略 " + strategy_id + " 更新成功");
        return AccountResult(AccountErrorCode::SUCCESS, "更新成功");
    } else {
        LOG_ERROR("[账户管理|Binance] 策略 " + strategy_id + " 更新失败");
        return AccountResult(
            AccountErrorCode::UPDATE_FAILED,
            "更新失败"
        );
    }
}

AccountResult unregister_binance_account(const std::string& strategy_id) {
    // 1. 验证策略ID
    if (!validate_strategy_id(strategy_id)) {
        LOG_ERROR("[账户管理|Binance] 注销失败 - 无效的策略ID: " + strategy_id);
        return AccountResult(
            AccountErrorCode::INVALID_STRATEGY_ID,
            "策略ID无效"
        );
    }

    // 2. 检查是否存在
    if (!g_account_registry.is_registered(strategy_id, ExchangeType::BINANCE)) {
        LOG_WARN("[账户管理|Binance] 策略 " + strategy_id + " 未找到");
        return AccountResult(
            AccountErrorCode::ACCOUNT_NOT_FOUND,
            "账户未找到"
        );
    }

    // 3. 执行注销
    bool success = false;
    try {
        success = g_account_registry.unregister_account(strategy_id, ExchangeType::BINANCE);
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理|Binance] 注销异常: " + std::string(e.what()));
        return AccountResult(
            AccountErrorCode::INTERNAL_ERROR,
            "注销过程发生异常: " + std::string(e.what())
        );
    }

    if (success) {
        LOG_AUDIT("账户注销", "策略: " + strategy_id + " | 交易所: Binance");
        LOG_INFO("[账户管理|Binance] ✓ 策略 " + strategy_id + " 已注销");
        return AccountResult(AccountErrorCode::SUCCESS, "注销成功");
    } else {
        LOG_ERROR("[账户管理|Binance] 策略 " + strategy_id + " 注销失败");
        return AccountResult(
            AccountErrorCode::UNREGISTRATION_FAILED,
            "注销失败"
        );
    }
}

// ==================== 兼容性接口实现（向后兼容旧代码）====================

okx::OKXRestAPI* get_api_for_strategy(const std::string& strategy_id) {
    return get_okx_api_for_strategy(strategy_id);
}

AccountResult register_strategy_account(const std::string& strategy_id,
                                        const std::string& api_key,
                                        const std::string& secret_key,
                                        const std::string& passphrase,
                                        bool is_testnet) {
    return register_okx_account(strategy_id, api_key, secret_key, passphrase, is_testnet);
}

AccountResult update_strategy_account(const std::string& strategy_id,
                                      const std::string& api_key,
                                      const std::string& secret_key,
                                      const std::string& passphrase,
                                      bool is_testnet) {
    return update_okx_account(strategy_id, api_key, secret_key, passphrase, is_testnet);
}

AccountResult unregister_strategy_account(const std::string& strategy_id) {
    return unregister_okx_account(strategy_id);
}

// ==================== 通用查询接口实现 ====================

>>>>>>> origin/master
size_t get_registered_strategy_count() {
    return g_account_registry.count();
}

<<<<<<< HEAD
=======
std::vector<std::string> get_registered_strategy_ids() {
    std::vector<std::string> ids;

    try {
        nlohmann::json all_accounts = g_account_registry.get_all_accounts_info();

        // 收集OKX账户ID
        if (all_accounts.contains("okx") && all_accounts["okx"].is_array()) {
            for (const auto& account : all_accounts["okx"]) {
                if (account.contains("strategy_id")) {
                    std::string id = account["strategy_id"].get<std::string>();
                    if (id != "_default_") {
                        ids.push_back(id);
                    }
                }
            }
        }

        // 收集Binance账户ID
        if (all_accounts.contains("binance") && all_accounts["binance"].is_array()) {
            for (const auto& account : all_accounts["binance"]) {
                if (account.contains("strategy_id")) {
                    std::string id = account["strategy_id"].get<std::string>();
                    if (id != "_default_") {
                        ids.push_back(id);
                    }
                }
            }
        }

        // 去重
        std::sort(ids.begin(), ids.end());
        ids.erase(std::unique(ids.begin(), ids.end()), ids.end());

    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理] 获取策略ID列表失败: " + std::string(e.what()));
    }

    return ids;
}

bool is_strategy_registered(const std::string& strategy_id) {
    if (!validate_strategy_id(strategy_id)) {
        return false;
    }

    return g_account_registry.is_registered(strategy_id, ExchangeType::OKX) ||
           g_account_registry.is_registered(strategy_id, ExchangeType::BINANCE);
}

nlohmann::json get_all_accounts_info() {
    try {
        nlohmann::json info = g_account_registry.get_all_accounts_info();

        // 添加统计信息
        info["summary"] = {
            {"total_count", g_account_registry.count()},
            {"okx_count", g_account_registry.okx_count()},
            {"binance_count", g_account_registry.binance_count()}
        };

        return info;
    } catch (const std::exception& e) {
        LOG_ERROR("[账户管理] 获取账户信息失败: " + std::string(e.what()));
        return nlohmann::json::object();
    }
}

size_t batch_register_accounts(const nlohmann::json& accounts) {
    if (!accounts.is_array()) {
        LOG_ERROR("[账户管理|批量] 批量注册失败 - 参数不是数组");
        return 0;
    }

    size_t success_count = 0;
    size_t okx_count = 0;
    size_t binance_count = 0;

    for (const auto& account : accounts) {
        try {
            std::string strategy_id = account.value("strategy_id", "");
            std::string exchange = account.value("exchange", "okx");
            std::string api_key = account.value("api_key", "");
            std::string secret_key = account.value("secret_key", "");
            bool is_testnet = account.value("is_testnet", true);

            // 转换为小写以支持大小写不敏感
            std::transform(exchange.begin(), exchange.end(), exchange.begin(), ::tolower);

            if (exchange == "okx") {
                std::string passphrase = account.value("passphrase", "");
                AccountResult result = register_okx_account(
                    strategy_id, api_key, secret_key, passphrase, is_testnet
                );
                if (result.is_success()) {
                    success_count++;
                    okx_count++;
                } else {
                    LOG_WARN("[账户管理|批量] OKX账户 " + strategy_id + " 注册失败: " + result.message);
                }
            } else if (exchange == "binance") {
                std::string market = account.value("market", "futures");
                AccountResult result = register_binance_account(
                    strategy_id, api_key, secret_key, is_testnet, market
                );
                if (result.is_success()) {
                    success_count++;
                    binance_count++;
                } else {
                    LOG_WARN("[账户管理|批量] Binance账户 " + strategy_id + " 注册失败: " + result.message);
                }
            } else {
                LOG_WARN("[账户管理|批量] 不支持的交易所类型: " + exchange);
            }

        } catch (const std::exception& e) {
            LOG_ERROR("[账户管理|批量] 注册单个账户失败: " + std::string(e.what()));
        }
    }

    std::stringstream summary;
    summary << "批量注册完成 - 总成功: " << success_count << "/" << accounts.size()
            << " (OKX: " << okx_count << ", Binance: " << binance_count << ")";
    LOG_INFO("[账户管理|批量] " + summary.str());

    return success_count;
}

size_t batch_unregister_accounts(const std::vector<std::string>& strategy_ids) {
    size_t success_count = 0;
    size_t okx_count = 0;
    size_t binance_count = 0;

    for (const auto& strategy_id : strategy_ids) {
        try {
            // 尝试注销OKX账户
            if (g_account_registry.is_registered(strategy_id, ExchangeType::OKX)) {
                AccountResult result = unregister_okx_account(strategy_id);
                if (result.is_success()) {
                    success_count++;
                    okx_count++;
                } else {
                    LOG_WARN("[账户管理|批量] OKX账户 " + strategy_id + " 注销失败: " + result.message);
                }
            }
            // 尝试注销Binance账户
            else if (g_account_registry.is_registered(strategy_id, ExchangeType::BINANCE)) {
                AccountResult result = unregister_binance_account(strategy_id);
                if (result.is_success()) {
                    success_count++;
                    binance_count++;
                } else {
                    LOG_WARN("[账户管理|批量] Binance账户 " + strategy_id + " 注销失败: " + result.message);
                }
            }
            // 账户不存在
            else {
                LOG_WARN("[账户管理|批量] 策略 " + strategy_id + " 未找到（OKX或Binance）");
            }

        } catch (const std::exception& e) {
            LOG_ERROR("[账户管理|批量] 注销账户 " + strategy_id + " 失败: " + std::string(e.what()));
        }
    }

    std::stringstream summary;
    summary << "批量注销完成 - 总成功: " << success_count << "/" << strategy_ids.size()
            << " (OKX: " << okx_count << ", Binance: " << binance_count << ")";
    LOG_INFO("[账户管理|批量] " + summary.str());

    return success_count;
}

>>>>>>> origin/master
} // namespace server
} // namespace trading
